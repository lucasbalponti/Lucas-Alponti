import pandas as pd
import numpy as np

def treinamento_perceptron(preditores, classes, taxa_aprendizagem):
    
    # Verificando se a matriz de preditores tem o mesmo número de amostras da matriz de classes    
    if (len(preditores) != len(classes)):
        print("É necessário ter o mesmo número de amostras para as variáveis e as classes.")
    else:
        # Iniciando o contador de épocas:
        época = 0
        
        # Iniciando o vetor de pesos com valores aleatórios entre 0 e 1
        w = np.random.rand(1, len(preditores[0])+1)
        
        print("O vetor de pesos inicial é:")
        print(w)
        print("\n")
        
        # Adicionando uma coluna de valores -1 à matriz de preditores, referente ao limiar de ativação
        preditores_atualizado = np.insert(preditores, 0, np.full((1, len(preditores)), -1), axis = 1)
        
        # Realizando o processo de treinamento
        while True:
        
            # Iniciando vetor para inserir valores de erro em cada treinamento
            vetor_erro = np.full((1, len(preditores_atualizado)), 0)
                
            for i in range(len(preditores_atualizado)):
                u = w * preditores_atualizado[i]

                funcao_g_u = u.sum()

                if (funcao_g_u < 0):
                    sinal = -1
                else:
                    sinal = 1

                if sinal != classes[i]:
                    vetor_erro[0][i] = 1
                    w = w + taxa_aprendizagem*(classes[i] - sinal)*preditores_atualizado[i]
                else:
                    vetor_erro[0][i] = 0

            época = época + 1
            
            if vetor_erro.sum() == 0:
                print("Treinamento finalizando em %s épocas" % (época))
                print("O vetor de pesos final é:")
                print(w)
                return w
                break

def operacao_perceptron(w, preditores):
    
    # Iniciando o vetor de resultados
    vetor_resultados = np.full((1, len(preditores)), 0)
    
    # Adicionando uma coluna de valores -1 à matriz de preditores, referente ao limiar de ativação
    preditores_atualizado = np.insert(preditores, 0, np.full((1, len(preditores)), -1), axis = 1)
        
    # Escrevendo os resultados no vetor
    for i in range(len(preditores_atualizado)):
        
        u = w * preditores_atualizado[i]
        
        funcao_g_u = u.sum()
        
        if (funcao_g_u < 0):
            sinal = -1
        else:
            sinal = 1
        
        vetor_resultados[0][i] = sinal
    
    return vetor_resultados
